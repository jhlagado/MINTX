0000                             ; comment out this .engine line if you want to single-step
0000                             ; through the code of your test
0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                .macro EXPECT,msg1,val1
0000                             ; 
0000                 POP HL
0000                 PUSH HL
0000                 LD DE,val1
0000                 OR A
0000                 SBC HL,DE
0000                 LD A,L
0000                 OR H
0000                 pop hl
0000                 JR Z,expect%%M
0000                 CALL printStr
0000                 .cstr "\r\n\r\n",msg1,"\r\nActual: "
0000                 CALL printdec
0000                 CALL printStr
0000                 .cstr "\r\nExpected: "
0000                 LD HL,val1
0000                 CALL printdec
0000                 HALT
0000                 .cstr
0000                expect%%M:
0000                .endm
0000                 
0000                .macro TEST,code1,val1
0000                             ; 
0000                 LD SP,DSTACK
0000                 CALL init
0000                 CALL enter
0000                 .cstr code1
0000                 expect code1,val1
0000                .endm
0000                 
0000                .macro PRINT,msg1
0000                             ; 
0000                 CALL printStr
0000                 .cstr "\r\n",msg1,"\r\n"
0000                .endm
0000                 
0000                             ; 
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 06 0A               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 08 0A               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 0A 0A               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 0C 0A               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 0E 0A               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 10 0A               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 14 0A               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 16 0A               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 18 0A               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 1A 0A               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 06 0A               LD   (RST08),HL   
0094   22 08 0A               LD   (RST10),HL   
0097   22 0A 0A               LD   (RST18),HL   
009A   22 0C 0A               LD   (RST20),HL   
009D   22 0E 0A               LD   (RST28),HL   
00A0   22 10 0A               LD   (RST30),HL   
00A3   22 14 0A               LD   (INTVEC),HL   
00A6   22 16 0A               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 18 0A               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 1A 0A               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 00 40               JP   testsStart   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       MintX 1.0 Extended Minimal Interpreter for the Z80
00C6                             ; 
00C6                             ;       John Hardy
00C6                             ;       incorporates code by Ken Boak and Craig Jones
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                TRUE:     EQU   -1   
00C6                FALSE:    EQU   0   
00C6                CTRL_C:   EQU   3   
00C6                CTRL_H:   EQU   8   
00C6                .macro LITDAT,len
00C6                             ; 
00C6                 db len
00C6                .endm
00C6                 
00C6                .macro REPDAT,len,data
00C6                             ; 
00C6                 db (len | $80)
00C6                 db data
00C6                .endm
00C6                 
00C6                .macro ENDDAT,
00C6                             ; 
00C6                 db 0
00C6                .endm
00C6                 
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put MintX code from here	
0180                IOPCODES:      
0180                          ;*Macro unroll:  LITDAT 15
0180   0F                     DB   15   
0181   1D                     DB   lsb(bang_)   ;   !
0182   00                     DB   lsb(dquote_)   ;   "
0183   00                     DB   lsb(hash_)   ;   #
0184   00                     DB   lsb(dollar_)   ;   $
0185   00                     DB   lsb(percent_)   ;   %
0186   00                     DB   lsb(amper_)   ;   &
0187   00                     DB   lsb(quote_)   ;   '
0188   00                     DB   lsb(lparen_)   ;   (
0189   00                     DB   lsb(rparen_)   ;   )
018A   00                     DB   lsb(star_)   ;   *
018B   2D                     DB   lsb(plus_)   ;   +
018C   00                     DB   lsb(comma_)   ;   ,
018D   00                     DB   lsb(minus_)   ;   -
018E   45                     DB   lsb(dot_)   ;   .
018F   64                     DB   lsb(slash_)   ;   /	
0190                          ;*Macro unroll:  REPDAT 10, lsb(num_)	; 10 x repeat lsb of add to the num routine
0190   8A                     DB   (10 | $80)   ; 10 x repeat lsb of add to the num routine
0191   02                     DB   lsb(num_)   
0192                          ;*Macro unroll:  LITDAT 7
0192   07                     DB   7   
0193   61                     DB   lsb(colon_)   ;    :
0194   50                     DB   lsb(semi_)   ;    ;
0195   00                     DB   lsb(lt_)   ;    <
0196   00                     DB   lsb(eq_)   ;    =
0197   00                     DB   lsb(gt_)   ;    >
0198   00                     DB   lsb(question_)   ;    ?
0199   00                     DB   lsb(at_)   ;    @
019A                          ;*Macro unroll:  REPDAT 26, lsb(call_)	; call a command a, B ....Z
019A   9A                     DB   (26 | $80)   ; call a command a, B ....Z
019B   3B                     DB   lsb(call_)   
019C                          ;*Macro unroll:  LITDAT 6
019C   06                     DB   6   
019D   00                     DB   lsb(lbrack_)   ;    [
019E   00                     DB   lsb(bslash_)   ;    \
019F   00                     DB   lsb(rbrack_)   ;    ]
01A0   00                     DB   lsb(caret_)   ;    ^
01A1   00                     DB   lsb(underscore_)   ;    _
01A2   00                     DB   lsb(grave_)   ;    `   ; for printing `hello`
01A3                          ;*Macro unroll:  REPDAT 26, lsb(var_)	; a b c .....z
01A3   9A                     DB   (26 | $80)   ; a b c .....z
01A4   05                     DB   lsb(var_)   
01A5                          ;*Macro unroll:  LITDAT 4
01A5   04                     DB   4   
01A6   00                     DB   lsb(lbrace_)   ;    {
01A7   00                     DB   lsb(pipe_)   ;    |
01A8   00                     DB   lsb(rbrace_)   ;    }
01A9   00                     DB   lsb(tilde_)   ;    ~ ( a b c -- b c a ) rotate
01AA                          ;*Macro unroll:  ENDDAT
01AA   00                     DB   0   
01AB                INIT:        
01AB   ED 73 8C 0C            LD   (vStkStart),sp   
01AF   DD 21 80 09            LD   ix,RSTACK   
01B3   DD 22 9C 0C            LD   (vBasePtr),ix   
01B7   FD 21 72 02            LD   iy,NEXT   ; iy provides a faster jump to NEXT
01BB   21 00 0C               LD   hl,vars   
01BE   54 5D                  LD   de,hl   
01C0   13                     INC   de   
01C1   36 00                  LD   (hl),0   
01C3   01 9C 00               LD   bc,VARS_SIZE * 3   ; init vars, defs and altVars
01C6   ED B0                  LDIR      
01C8   21 A0 0C               LD   hl,HEAP   
01CB   22 76 0C               LD   (vHeapPtr),hl   
01CE   21 80 01               LD   hl,iOpcodes   
01D1   11 00 0B               LD   de,opcodes   
01D4   01 78 00               LD   bc,$80-32-1-1+26   
01D7                INITOPS1:      
01D7   7E                     LD   a,(hl)   
01D8   23                     INC   hl   
01D9   CB 27                  SLA   A   
01DB   C8                     RET   z   
01DC   38 09                  JR   C,initOps2   
01DE   CB 3F                  SRL   A   
01E0   4F                     LD   C,A   
01E1   06 00                  LD   B,0   
01E3   ED B0                  LDIR      
01E5   18 F0                  JR   initOps1   
01E7                INITOPS2:      
01E7   CB 3F                  SRL   A   
01E9   47                     LD   B,A   
01EA   7E                     LD   a,(hl)   
01EB   23                     INC   hl   
01EC                INITOPS2A:      
01EC   12                     LD   (de),A   
01ED   13                     INC   de   
01EE   10 FC                  DJNZ   initOps2a   
01F0   18 E5                  JR   initOps1   
01F2                START:       ; start of MintX
01F2   31 00 0A               LD   SP,DSTACK   
01F5   CD AB 01               CALL   init   
01F8   CD F0 02               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
01FB   4D 69 6E 74 58 32 2E 30 0D 0A 00 .CSTR   "MintX2.0\r\n"   
0206                INTERPRET:      
0206   CD E0 02               CALL   prompt   
0209   01 00 00               LD   bc,0   ; load bc with offset into TIB, decide char into tib or execute or control
020C   ED 43 7C 0C            LD   (vTIBPtr),bc   
0210                INTERPRET2:      ; calc nesting
0210   1E 00                  LD   E,0   ; initilize nesting value
0212   C5                     PUSH   bc   ; save offset into TIB,
0213                             ; bc is also the count of chars in TIB
0213   21 00 08               LD   hl,TIB   ; hl is start of TIB
0216   18 06                  JR   interpret4   
0218                INTERPRET3:      
0218   7E                     LD   a,(hl)   ; A = char in TIB
0219   23                     INC   hl   ; inc pointer into TIB
021A   0B                     DEC   bc   ; dec count of chars in TIB
021B   CD B9 02               CALL   nesting   ; update nesting value
021E                INTERPRET4:      
021E   79                     LD   a,C   ; is count zero?
021F   B0                     OR   B   
0220   20 F6                  JR   NZ,interpret3   ; if not loop
0222   C1                     POP   bc   ; restore offset into TIB
0223                WAITCHAR:      
0223   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
0226   FE 20                  CP   $20   ; compare to space
0228   30 1C                  JR   NC,waitchar1   ; if >= space, if below 20 set cary flag
022A   FE 00                  CP   $0   ; is it end of string? null end of string
022C   28 3C                  JR   Z,waitchar4   
022E   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0230   28 22                  JR   Z,waitchar3   ; if anything else its control char
0232   FE 08                  CP   CTRL_H   
0234   28 02                  JR   z,backSpace   
0236   18 D8                  JR   interpret2   
0238                BACKSPACE:      
0238   79                     LD   a,c   
0239   B0                     OR   b   
023A   28 D4                  JR   z,interpret2   
023C   0B                     DEC   bc   
023D   CD F0 02               CALL   printStr   
0240   08 20 08 00            .CSTR   "\b \b"   
0244   18 CA                  JR   interpret2   
0246                WAITCHAR1:      
0246   21 00 08               LD   hl,TIB   
0249   09                     ADD   hl,bc   
024A   77                     LD   (hl),A   ; store the character in textbuf
024B   03                     INC   bc   
024C   CD 85 00               CALL   putchar   ; echo character to screen
024F   CD B9 02               CALL   nesting   
0252   18 CF                  JR   waitchar   ; wait for next character
0254                WAITCHAR3:      
0254   21 00 08               LD   hl,TIB   
0257   09                     ADD   hl,bc   
0258   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
025A   23                     INC   hl   
025B   36 0A                  LD   (hl),"\n"   
025D   23                     INC   hl   ; ????
025E   03                     INC   bc   
025F   03                     INC   bc   
0260   CD E9 02               CALL   crlf   ; echo character to screen
0263   7B                     LD   a,E   ; if zero nesting append and ETX after \r
0264   B7                     OR   A   
0265   20 BC                  JR   NZ,waitchar   
0267   36 03                  LD   (hl),$03   ; store end of text ETX in text buffer
0269   03                     INC   bc   
026A                WAITCHAR4:      
026A   ED 43 7C 0C            LD   (vTIBPtr),bc   
026E   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERE, we pressed enter
0271   0B                     DEC   bc   
0272                NEXT:        
0272   03                     INC   bc   ; Increment the IP
0273   0A                     LD   a,(bc)   ; Get the next character and dispatch
0274   B7                     OR   a   ; is it NUL?
0275   28 0F                  JR   z,exit   
0277   FE 03                  CP   CTRL_C   
0279   28 1F                  JR   z,etx   
027B   D6 21                  SUB   "!"   
027D   38 F3                  JR   c,NEXT   
027F   6F                     LD   L,A   ; Index into table
0280   26 0B                  LD   H,msb(opcodes)   ; Start address of jump table
0282   6E                     LD   L,(hl)   ; get low jump address
0283   26 04                  LD   H,msb(page4)   ; Load H with the 1st page address
0285   E9                     JP   (hl)   ; Jump to routine
0286                EXIT:        
0286   03                     INC   bc   ; store offests into a table of bytes, smaller
0287   50 59                  LD   de,bc   
0289   DD 2A 9C 0C            LD   ix,(vBasePtr)   ; 
028D   CD 0B 03               CALL   rpop   ; Restore old base pointer
0290   22 9C 0C               LD   (vBasePtr),hl   
0293   CD 0B 03               CALL   rpop   ; Restore Instruction pointer
0296   44 4D                  LD   bc,hl   
0298   EB                     EX   de,hl   
0299   E9                     JP   (hl)   
029A                ETX:         
029A   21 00 F6               LD   hl,-DSTACK   ; check if stack pointer is underwater
029D   39                     ADD   hl,SP   
029E   30 03                  JR   NC,etx1   
02A0   31 00 0A               LD   SP,DSTACK   
02A3                ETX1:        
02A3   C3 06 02               JP   interpret   
02A6                LOOKUPREF0:      
02A6   21 34 0C               LD   hl,defs   
02A9   D6 41                  SUB   "A"   
02AB   18 02                  JR   lookupRef1   
02AD                LOOKUPREF:      
02AD   D6 61                  SUB   "a"   
02AF                LOOKUPREF1:      
02AF   87                     ADD   a,a   
02B0   85                     ADD   a,l   
02B1   6F                     LD   l,a   
02B2   3E 00                  LD   a,0   
02B4   8C                     ADC   a,h   
02B5   67                     LD   h,a   
02B6   AF                     XOR   a   
02B7   B3                     OR   e   ; sets Z flag if A-Z
02B8   C9                     RET      
02B9                             ; **************************************************************************
02B9                             ; calculate nesting value
02B9                             ; A is char to be tested,
02B9                             ; E is the nesting value (initially 0)
02B9                             ; E is increased by ( and [
02B9                             ; E is decreased by ) and ]
02B9                             ; E has its bit 7 toggled by `
02B9                             ; limited to 127 levels
02B9                             ; **************************************************************************
02B9                NESTING:      
02B9   FE 60                  CP   "`"   
02BB   20 05                  JR   NZ,nesting1   
02BD   3E 80                  LD   a,$80   
02BF   AB                     XOR   e   
02C0   5F                     LD   e,a   
02C1   C9                     RET      
02C2                NESTING1:      
02C2   CB 7B                  BIT   7,E   
02C4   C0                     RET   NZ   
02C5   FE 3A                  CP   ":"   
02C7   28 08                  JR   Z,nesting2   
02C9   FE 5B                  CP   "["   
02CB   28 04                  JR   Z,nesting2   
02CD   FE 28                  CP   "("   
02CF   20 02                  JR   NZ,nesting3   
02D1                NESTING2:      
02D1   1C                     INC   E   
02D2   C9                     RET      
02D3                NESTING3:      
02D3   FE 3B                  CP   ";"   
02D5   28 07                  JR   Z,nesting4   
02D7   FE 5D                  CP   "]"   
02D9   28 03                  JR   Z,nesting4   
02DB   FE 29                  CP   ")"   
02DD   C0                     RET   NZ   
02DE                NESTING4:      
02DE   1D                     DEC   E   
02DF   C9                     RET      
02E0                PROMPT:      
02E0   CD F0 02               CALL   printStr   
02E3   0D 0A 3E 20 00         .CSTR   "\r\n> "   
02E8   C9                     RET      
02E9                CRLF:        
02E9   CD F0 02               CALL   printStr   
02EC   0D 0A 00               .CSTR   "\r\n"   
02EF   C9                     RET      
02F0                PRINTSTR:      
02F0   E3                     EX   (SP),hl   ; swap			
02F1   CD FB 02               CALL   putStr   
02F4   23                     INC   hl   ; inc past null
02F5   E3                     EX   (SP),hl   ; put it back	
02F6   C9                     RET      
02F7                PUTSTR0:      
02F7   CD 85 00               CALL   putchar   
02FA   23                     INC   hl   
02FB                PUTSTR:      
02FB   7E                     LD   a,(hl)   
02FC   B7                     OR   A   
02FD   20 F8                  JR   NZ,putStr0   
02FF   C9                     RET      
0300                RPUSH:       
0300   DD 2B                  DEC   IX   
0302   DD 74 00               LD   (IX+0),H   
0305   DD 2B                  DEC   IX   
0307   DD 75 00               LD   (IX+0),L   
030A   C9                     RET      
030B                RPOP:        
030B   DD 6E 00               LD   L,(IX+0)   
030E   DD 23                  INC   IX   
0310   DD 66 00               LD   H,(IX+0)   
0313   DD 23                  INC   IX   
0315                RPOP2:       
0315   C9                     RET      
0316                WRITECHAR:      
0316   77                     LD   (hl),A   
0317   23                     INC   hl   
0318   C3 85 00               JP   putchar   
031B                ENTER:       
031B   60 69                  LD   hl,bc   
031D   CD 00 03               CALL   rpush   ; save Instruction Pointer
0320   2A 9C 0C               LD   hl,(vBasePtr)   
0323   CD 00 03               CALL   rpush   
0326   DD 22 9C 0C            LD   (vBasePtr),ix   
032A   C1                     POP   bc   
032B   0B                     DEC   bc   
032C   FD E9                  JP   (iy)   
032E                FALSE_:      
032E   21 00 00               LD   hl,FALSE   
0331   18 03                  JR   true1   
0333                TRUE_:       
0333   21 FF FF               LD   hl,TRUE   
0336                TRUE1:       
0336   E5                     PUSH   hl   
0337   FD E9                  JP   (iy)   
0339                             ; **********************************************************************			
0339                             ; Page 4 primitive routines
0339                             ; **********************************************************************
0339                          ALIGN   $100   
0400                PAGE4:       
0400                BSLASH_:      
0400                QUOTE_:      ; Discard the top member of the stack
0400                AT_:         
0400                UNDERSCORE_:      
0400                PERCENT_:      
0400                AMPER_:      
0400                PIPE_:       
0400                CARET_:      
0400                TILDE_:      
0400                INVERT:      ; Bitwise INVert the top member of the stack
0400                DQUOTE_:      
0400                COMMA_:      ; print hexadecimal
0400                LBRACE_:      
0400                RBRACE_:      
0400                DOLLAR_:      
0400                MINUS_:      ; Subtract the value 2nd on stack from top of stack
0400                EQ_:         
0400                GT_:         
0400                LT_:         
0400                GRAVE_:      
0400                RPAREN_:      
0400                LBRACK_:      
0400                RBRACK_:      
0400                LPAREN_:      
0400                QUESTION_:      
0400                HASH_:       
0400                STAR_:       
0400   FD E9                  JP   (iy)   
0402                NUM_:        
0402   C3 B3 05               JP   num   
0405                VAR_:        
0405   0A                     LD   a,(bc)   
0406   21 00 0C               LD   hl,vars   
0409   CD AD 02               CALL   lookupRef   
040C                VAR1:        
040C   22 9E 0C               LD   (vPointer),hl   
040F   16 00                  LD   d,0   
0411   5E                     LD   e,(hl)   
0412   3A 6A 0C               LD   a,(vByteMode)   
0415   3C                     INC   a   ; is it byte?
0416   28 02                  JR   z,var2   
0418   23                     INC   hl   
0419   56                     LD   d,(hl)   
041A                VAR2:        
041A   D5                     PUSH   de   
041B   FD E9                  JP   (iy)   
041D                BANG_:       ; Store the value at the address placed on the top of the stack
041D                ASSIGN:      
041D   E1                     POP   hl   ; discard value of last accessed variable
041E   D1                     POP   de   ; new value
041F   2A 9E 0C               LD   hl,(vPointer)   
0422   73                     LD   (hl),e   
0423   3A 6A 0C               LD   a,(vByteMode)   
0426   3C                     INC   a   ; is it byte?
0427   28 02                  JR   z,assign1   
0429   23                     INC   hl   
042A   72                     LD   (hl),d   
042B                ASSIGN1:      
042B   FD E9                  JP   (iy)   
042D                PLUS_:       ; add the top 2 members of the stack
042D   D1                     POP   de   
042E   E1                     POP   hl   
042F   19                     ADD   hl,de   
0430   E5                     PUSH   hl   
0431   21 00 00               LD   hl,0   
0434   CB 15                  RL   l   
0436   22 6C 0C               LD   (vCarry),hl   
0439   FD E9                  JP   (iy)   
043B                CALL_:       
043B   0A                     LD   a,(bc)   
043C   CD A6 02               CALL   lookupRef0   
043F   5E                     LD   E,(hl)   
0440   23                     INC   hl   
0441   56                     LD   D,(hl)   
0442   C3 12 05               JP   go1   
0445                DOT_:        
0445   E1                     POP   hl   
0446   CD 41 05               CALL   printDec   
0449                DOT2:        
0449   3E 20                  LD   a," "   
044B   CD 85 00               CALL   putChar   
044E   FD E9                  JP   (iy)   
0450                SEMI_:       
0450   DD 2A 9C 0C            LD   ix,(vBasePtr)   ; 
0454   CD 0B 03               CALL   rpop   ; Restore old base pointer
0457   22 9C 0C               LD   (vBasePtr),hl   
045A   CD 0B 03               CALL   rpop   ; Restore Instruction pointer
045D   44 4D                  LD   bc,hl   
045F   FD E9                  JP   (iy)   
0461                COLON_:      
0461   C3 89 05               JP   def   
0464                SLASH_:      
0464                ALT_:        ; falls through (must be on page 4)
0464                             ;*******************************************************************
0464                             ; Page 5 primitive routines
0464                             ;*******************************************************************
0464                             ; **************************************************************************
0464                             ; Page 6 Alt primitives
0464                             ; **************************************************************************
0464                          ALIGN   $100   
0500                PAGE6:       
0500                ANOP_:       
0500   FD E9                  JP   (iy)   
0502                FALSEX_:      
0502   C3 2E 03               JP   false_   
0505                PRINTCHAR_:      
0505   E1                     POP   hl   
0506   7D                     LD   a,L   
0507   CD 85 00               CALL   putchar   
050A   FD E9                  JP   (iy)   
050C                PROMPT_:      
050C   CD E0 02               CALL   prompt   
050F   FD E9                  JP   (iy)   
0511                GO_:         
0511   D1                     POP   de   
0512                GO1:         
0512   7A                     LD   a,D   ; skip if destination address is null
0513   B3                     OR   E   
0514   28 18                  JR   Z,go3   
0516   60 69                  LD   hl,bc   
0518   03                     INC   bc   ; read next char from source
0519   0A                     LD   a,(bc)   ; if ; to tail call optimise
051A   FE 3B                  CP   ";"   ; by jumping to rather than calling destination
051C   28 0D                  JR   Z,go2   
051E   CD 00 03               CALL   rpush   ; save Instruction Pointer
0521   2A 9C 0C               LD   hl,(vBasePtr)   
0524   CD 00 03               CALL   rpush   
0527   DD 22 9C 0C            LD   (vBasePtr),ix   
052B                GO2:         
052B   42 4B                  LD   bc,de   
052D   0B                     DEC   bc   
052E                GO3:         
052E   FD E9                  JP   (iy)   
0530                NEWLN_:      
0530   CD E9 02               CALL   crlf   
0533   FD E9                  JP   (iy)   
0535                TRUEX_:      
0535   C3 33 03               JP   true_   
0538                VARACCESS_:      
0538   21 9E 0C               LD   hl,vPointer   
053B   5E                     LD   e,(hl)   
053C   23                     INC   hl   
053D   56                     LD   d,(hl)   
053E   D5                     PUSH   de   
053F   FD E9                  JP   (iy)   
0541                             ;*******************************************************************
0541                             ; Subroutines
0541                             ;*******************************************************************
0541                             ; hl = value
0541                PRINTDEC:      
0541   CB 7C                  BIT   7,h   
0543   28 0B                  JR   z,printDec2   
0545   3E 2D                  LD   a,"-"   
0547   CD 85 00               CALL   putchar   
054A   AF                     XOR   a   
054B   95                     SUB   l   
054C   6F                     LD   l,a   
054D   9F                     SBC   a,a   
054E   94                     SUB   h   
054F   67                     LD   h,a   
0550                PRINTDEC2:      
0550   C5                     PUSH   bc   
0551   0E 00                  LD   c,0   ; leading zeros flag = false
0553   11 F0 D8               LD   de,-10000   
0556   CD 72 05               CALL   printDec4   
0559   11 18 FC               LD   de,-1000   
055C   CD 72 05               CALL   printDec4   
055F   11 9C FF               LD   de,-100   
0562   CD 72 05               CALL   printDec4   
0565   1E F6                  LD   e,-10   
0567   CD 72 05               CALL   printDec4   
056A   0C                     INC   c   ; flag = true for at least digit
056B   1E FF                  LD   e,-1   
056D   CD 72 05               CALL   printDec4   
0570   C1                     POP   bc   
0571   C9                     RET      
0572                PRINTDEC4:      
0572   06 2F                  LD   b,"0"-1   
0574                PRINTDEC5:      
0574   04                     INC   b   
0575   19                     ADD   hl,de   
0576   38 FC                  JR   c,printDec5   
0578   ED 52                  SBC   hl,de   
057A   3E 30                  LD   a,"0"   
057C   B8                     CP   b   
057D   20 05                  JR   nz,printDec6   
057F   AF                     XOR   a   
0580   B1                     OR   c   
0581   C8                     RET   z   
0582   18 01                  JR   printDec7   
0584                PRINTDEC6:      
0584   0C                     INC   c   
0585                PRINTDEC7:      
0585   78                     LD   a,b   
0586   C3 85 00               JP   putchar   
0589                             ;*******************************************************************
0589                             ; Page 5 primitive routines continued
0589                             ;*******************************************************************
0589                DEF:         ; Create a colon definition
0589   03                     INC   bc   
058A   0A                     LD   a,(bc)   ; Get the next character
058B   FE 3A                  CP   ":"   ; is it anonymouse
058D   20 08                  JR   nz,def0   
058F   03                     INC   bc   
0590   ED 5B 76 0C            LD   de,(vHeapPtr)   ; return start of definition
0594   D5                     PUSH   de   
0595   18 0B                  JR   def1   
0597                DEF0:        
0597   CD A6 02               CALL   lookupRef0   
059A   ED 5B 76 0C            LD   de,(vHeapPtr)   ; start of defintion
059E   73                     LD   (hl),E   ; Save low byte of address in CFA
059F   23                     INC   hl   
05A0   72                     LD   (hl),D   ; Save high byte of address in CFA+1
05A1   03                     INC   bc   
05A2                DEF1:        ; Skip to end of definition
05A2   0A                     LD   a,(bc)   ; Get the next character
05A3   03                     INC   bc   ; Point to next character
05A4   12                     LD   (de),A   
05A5   13                     INC   de   
05A6   FE 3B                  CP   ";"   ; Is it a semicolon
05A8   28 02                  JR   Z,def2   ; end the definition
05AA   18 F6                  JR   def1   ; get the next element
05AC                DEF2:        
05AC   0B                     DEC   bc   
05AD                DEF3:        
05AD   ED 53 76 0C            LD   (vHeapPtr),de   ; bump heap ptr to after definiton
05B1   FD E9                  JP   (iy)   
05B3                NUM:         
05B3   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
05B6   0A                     LD   a,(bc)   ; Get numeral or -
05B7   FE 2D                  CP   "-"   
05B9   20 01                  JR   nz,num0   
05BB   03                     INC   bc   ; move to next char, no flags affected
05BC                NUM0:        
05BC   08                     EX   af,af'   ; save zero flag = 0 for later
05BD                NUM1:        
05BD   0A                     LD   a,(bc)   ; read digit
05BE   D6 30                  SUB   "0"   ; less than 0?
05C0   38 13                  JR   c,num2   ; not a digit, exit loop
05C2   FE 0A                  CP   10   ; greater that 9?
05C4   30 0F                  JR   nc,num2   ; not a digit, exit loop
05C6   03                     INC   bc   ; inc IP
05C7   54 5D                  LD   de,hl   ; multiply hl * 10
05C9   29                     ADD   hl,hl   
05CA   29                     ADD   hl,hl   
05CB   19                     ADD   hl,de   
05CC   29                     ADD   hl,hl   
05CD   85                     ADD   a,l   ; add digit in a to hl
05CE   6F                     LD   l,a   
05CF   3E 00                  LD   a,0   
05D1   8C                     ADC   a,h   
05D2   67                     LD   h,a   
05D3   18 E8                  JR   num1   
05D5                NUM2:        
05D5   0B                     DEC   bc   
05D6   08                     EX   af,af'   ; restore zero flag
05D7   20 07                  JR   nz,num3   
05D9   EB                     EX   de,hl   ; negate the value of hl
05DA   21 00 00               LD   hl,0   
05DD   B7                     OR   a   ; jump to sub2
05DE   ED 52                  SBC   hl,de   
05E0                NUM3:        
05E0   E5                     PUSH   hl   ; Put the number on the stack
05E1   FD E9                  JP   (iy)   ; and process the next character
05E3                             ; *******************************************************************************
05E3                             ; *********  END OF MAIN   ******************************************************
05E3                             ; *******************************************************************************
05E3                             ; *******************************************************************************
05E3                DSIZE:    EQU   $80   
05E3                RSIZE:    EQU   $80   
05E3                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
05E3                VARS_SIZE:   EQU   26*2   
0800                          .ORG   RAMSTART   
0800                TIB:      DS   TIBSIZE   
0900                          DS   RSIZE   
0980                RSTACK:      
0980                          DS   DSIZE   
0A00                DSTACK:      
0A00                STACK:       
0A00                TBPTR:    DS   2   ; reserved for tests
0A02                VTEMP1:   DS   2   ; 
0A04                VTEMP2:   DS   2   ; 
0A06                RST08:    DS   2   
0A08                RST10:    DS   2   
0A0A                RST18:    DS   2   
0A0C                RST20:    DS   2   
0A0E                RST28:    DS   2   
0A10                RST30:    DS   2   ; 
0A12                BAUD:     DS   2   ; 
0A14                INTVEC:   DS   2   ; 
0A16                NMIVEC:   DS   2   ; 
0A18                GETCVEC:   DS   2   ; 
0A1A                PUTCVEC:   DS   2   ; 
0A1C                          ALIGN   $100   
0B00                OPCODES:      
0B00                          DS   $80-32-1-1   
0B5E                ALTCODES:      
0B5E                          DS   26   
0B78                          ALIGN   $100   
0C00                VARS:     DS   VARS_SIZE   
0C34                DEFS:     DS   VARS_SIZE   
0C68                ALTVARS:      
0C68                          DS   2   ; a
0C6A                VBYTEMODE:   DS   2   ; b
0C6C                VCARRY:   DS   2   ; c carry variable
0C6E                          DS   2   ; d
0C70                          DS   2   ; e
0C72                          DS   2   ; f
0C74                          DS   2   ; g
0C76                VHEAPPTR:   DS   2   ; h heap pointer variable
0C78                          DS   2   ; i loop variable
0C7A                          DS   2   ; j outer loop variable
0C7C                VTIBPTR:   DS   2   ; k address of text input buffer
0C7E                          DS   2   ; l
0C80                          DS   2   ; m
0C82                          DS   2   ; n
0C84                          DS   2   ; o
0C86                          DS   2   ; p
0C88                          DS   2   ; q
0C8A                VREMAIN:   DS   2   ; r remainder of last division
0C8C                VSTKSTART:   DS   2   ; s address of start of stack
0C8E                          DS   2   ; t
0C90                          DS   2   ; u
0C92                          DS   2   ; v
0C94                          DS   2   ; w
0C96                          DS   2   ; x
0C98                          DS   2   ; y
0C9A                          DS   2   ; z name of last defined function
0C9C                VBASEPTR:   DS   2   
0C9E                VPOINTER:   DS   2   ; 
0CA0                HEAP:        
0CA0                             ; 
4000                          .ORG   $4000   
4000                             ; 
4000                TESTSSTART:      
4000                             ; 
4000                             ; write your string containing a line of MintX code 
4000                             ; followed by the expected value of the top of stack after running it
4000                             ; test "0t! /u(/i 4 < /W t 1+ t!) t ", 4
4000                          ;*Macro unroll:  test "1 2 +", 3
4000   31 00 0A               LD   SP,DSTACK   
4003   CD AB 01               CALL   init   
4006   CD 1B 03               CALL   enter   
4009   31 20 32 20 2B 00      .CSTR   "1 2 +"   
400F                          ;*Macro unroll:  expect "1 2 +",3
400F   E1                     POP   HL   
4010   E5                     PUSH   HL   
4011   11 03 00               LD   DE,3   
4014   B7                     OR   A   
4015   ED 52                  SBC   HL,DE   
4017   7D                     LD   A,L   
4018   B4                     OR   H   
4019   E1                     POP   hl   
401A   28 32                  JR   Z,expectM_0_1232S31   
401C   CD F0 02               CALL   printStr   
401F   0D 0A 0D 0A 31 20 32 20 2B 0D 0A 41 63 74 75 61 6C 3A 20 00 .CSTR   "\r\n\r\n","1 2 +","\r\nActual: "   
4033   CD 41 05               CALL   printdec   
4036   CD F0 02               CALL   printStr   
4039   0D 0A 45 78 70 65 63 74 65 64 3A 20 00 .CSTR   "\r\nExpected: "   
4046   21 03 00               LD   HL,3   
4049   CD 41 05               CALL   printdec   
404C   76                     HALT      
404D   00                     .CSTR      
404E                EXPECTM_0_1232S31:      
404E                             ; 
404E                             ; if the tests succeed, "Done!" while be printed       
404E                          ;*Macro unroll:  print "Done!"
404E   CD F0 02               CALL   printStr   
4051   0D 0A 44 6F 6E 65 21 0D 0A 00 .CSTR   "\r\n","Done!","\r\n"   
405B   76                     HALT      


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 117 IN IOSerial.asm
                    > USED AT LINE 123 IN IOSerial.asm
                    > USED AT LINE 129 IN IOSerial.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 141 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 189 IN IOSerial.asm
                    > USED AT LINE 36 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 6 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
                    > USED AT LINE 487 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 298 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 303 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 315 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 152 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 174 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 176 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 182 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 446 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 293 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 294 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 297 IN IOSerial.asm
                    > USED AT LINE 301 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 310 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 434 IN IOSerial.asm
                    > USED AT LINE 162 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 438 IN IOSerial.asm
                    > USED AT LINE 187 IN MAIN.asm
                    > USED AT LINE 321 IN MAIN.asm
                    > USED AT LINE 347 IN MAIN.asm
                    > USED AT LINE 461 IN MAIN.asm
                    > USED AT LINE 496 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
                    > USED AT LINE 589 IN MAIN.asm
RESET:              008B DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 13 IN MAIN.asm
                    > USED AT LINE 364 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 14 IN MAIN.asm
                    > USED AT LINE 360 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 15 IN MAIN.asm
                    > USED AT LINE 217 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
IOPCODES:           0180 DEFINED AT LINE 38 IN MAIN.asm
                    > USED AT LINE 103 IN MAIN.asm
INIT:               01AB DEFINED AT LINE 86 IN MAIN.asm
                    > USED AT LINE 132 IN MAIN.asm
                    > USED AT LINE 28
INITOPS1:           01D7 DEFINED AT LINE 107 IN MAIN.asm
                    > USED AT LINE 117 IN MAIN.asm
                    > USED AT LINE 128 IN MAIN.asm
INITOPS2:           01E7 DEFINED AT LINE 119 IN MAIN.asm
                    > USED AT LINE 112 IN MAIN.asm
INITOPS2A:          01EC DEFINED AT LINE 124 IN MAIN.asm
                    > USED AT LINE 127 IN MAIN.asm
START:              01F2 DEFINED AT LINE 130 IN MAIN.asm
INTERPRET:          0206 DEFINED AT LINE 136 IN MAIN.asm
                    > USED AT LINE 244 IN MAIN.asm
INTERPRET2:         0210 DEFINED AT LINE 142 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 176 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
INTERPRET3:         0218 DEFINED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 158 IN MAIN.asm
INTERPRET4:         021E DEFINED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 147 IN MAIN.asm
WAITCHAR:           0223 DEFINED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 189 IN MAIN.asm
                    > USED AT LINE 203 IN MAIN.asm
BACKSPACE:          0238 DEFINED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 170 IN MAIN.asm
WAITCHAR1:          0246 DEFINED AT LINE 182 IN MAIN.asm
                    > USED AT LINE 164 IN MAIN.asm
WAITCHAR3:          0254 DEFINED AT LINE 191 IN MAIN.asm
                    > USED AT LINE 168 IN MAIN.asm
WAITCHAR4:          026A DEFINED AT LINE 207 IN MAIN.asm
                    > USED AT LINE 166 IN MAIN.asm
NEXT:               0272 DEFINED AT LINE 212 IN MAIN.asm
                    > USED AT LINE 91 IN MAIN.asm
                    > USED AT LINE 220 IN MAIN.asm
EXIT:               0286 DEFINED AT LINE 227 IN MAIN.asm
                    > USED AT LINE 216 IN MAIN.asm
ETX:                029A DEFINED AT LINE 238 IN MAIN.asm
                    > USED AT LINE 218 IN MAIN.asm
ETX1:               02A3 DEFINED AT LINE 243 IN MAIN.asm
                    > USED AT LINE 241 IN MAIN.asm
LOOKUPREF0:         02A6 DEFINED AT LINE 246 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
                    > USED AT LINE 605 IN MAIN.asm
LOOKUPREF:          02AD DEFINED AT LINE 250 IN MAIN.asm
                    > USED AT LINE 410 IN MAIN.asm
LOOKUPREF1:         02AF DEFINED AT LINE 252 IN MAIN.asm
                    > USED AT LINE 249 IN MAIN.asm
NESTING:            02B9 DEFINED AT LINE 273 IN MAIN.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 188 IN MAIN.asm
NESTING1:           02C2 DEFINED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
NESTING2:           02D1 DEFINED AT LINE 289 IN MAIN.asm
                    > USED AT LINE 284 IN MAIN.asm
                    > USED AT LINE 286 IN MAIN.asm
NESTING3:           02D3 DEFINED AT LINE 292 IN MAIN.asm
                    > USED AT LINE 288 IN MAIN.asm
NESTING4:           02DE DEFINED AT LINE 299 IN MAIN.asm
                    > USED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 296 IN MAIN.asm
PROMPT:             02E0 DEFINED AT LINE 303 IN MAIN.asm
                    > USED AT LINE 137 IN MAIN.asm
                    > USED AT LINE 500 IN MAIN.asm
CRLF:               02E9 DEFINED AT LINE 308 IN MAIN.asm
                    > USED AT LINE 200 IN MAIN.asm
                    > USED AT LINE 525 IN MAIN.asm
PRINTSTR:           02F0 DEFINED AT LINE 313 IN MAIN.asm
                    > USED AT LINE 133 IN MAIN.asm
                    > USED AT LINE 178 IN MAIN.asm
                    > USED AT LINE 304 IN MAIN.asm
                    > USED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 12
                    > USED AT LINE 16
                    > USED AT LINE 35
PUTSTR0:            02F7 DEFINED AT LINE 320 IN MAIN.asm
                    > USED AT LINE 326 IN MAIN.asm
PUTSTR:             02FB DEFINED AT LINE 323 IN MAIN.asm
                    > USED AT LINE 315 IN MAIN.asm
RPUSH:              0300 DEFINED AT LINE 329 IN MAIN.asm
                    > USED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 353 IN MAIN.asm
                    > USED AT LINE 514 IN MAIN.asm
                    > USED AT LINE 516 IN MAIN.asm
RPOP:               030B DEFINED AT LINE 336 IN MAIN.asm
                    > USED AT LINE 231 IN MAIN.asm
                    > USED AT LINE 233 IN MAIN.asm
                    > USED AT LINE 466 IN MAIN.asm
                    > USED AT LINE 468 IN MAIN.asm
RPOP2:              0315 DEFINED AT LINE 341 IN MAIN.asm
WRITECHAR:          0316 DEFINED AT LINE 344 IN MAIN.asm
ENTER:              031B DEFINED AT LINE 349 IN MAIN.asm
                    > USED AT LINE 29
FALSE_:             032E DEFINED AT LINE 359 IN MAIN.asm
                    > USED AT LINE 491 IN MAIN.asm
TRUE_:              0333 DEFINED AT LINE 363 IN MAIN.asm
                    > USED AT LINE 529 IN MAIN.asm
TRUE1:              0336 DEFINED AT LINE 365 IN MAIN.asm
                    > USED AT LINE 361 IN MAIN.asm
PAGE4:              0400 DEFINED AT LINE 373 IN MAIN.asm
BSLASH_:            0400 DEFINED AT LINE 375 IN MAIN.asm
QUOTE_:             0400 DEFINED AT LINE 376 IN MAIN.asm
AT_:                0400 DEFINED AT LINE 377 IN MAIN.asm
UNDERSCORE_:        0400 DEFINED AT LINE 378 IN MAIN.asm
PERCENT_:           0400 DEFINED AT LINE 379 IN MAIN.asm
AMPER_:             0400 DEFINED AT LINE 380 IN MAIN.asm
PIPE_:              0400 DEFINED AT LINE 381 IN MAIN.asm
CARET_:             0400 DEFINED AT LINE 382 IN MAIN.asm
TILDE_:             0400 DEFINED AT LINE 383 IN MAIN.asm
INVERT:             0400 DEFINED AT LINE 384 IN MAIN.asm
DQUOTE_:            0400 DEFINED AT LINE 385 IN MAIN.asm
COMMA_:             0400 DEFINED AT LINE 386 IN MAIN.asm
LBRACE_:            0400 DEFINED AT LINE 387 IN MAIN.asm
RBRACE_:            0400 DEFINED AT LINE 388 IN MAIN.asm
DOLLAR_:            0400 DEFINED AT LINE 389 IN MAIN.asm
MINUS_:             0400 DEFINED AT LINE 390 IN MAIN.asm
EQ_:                0400 DEFINED AT LINE 391 IN MAIN.asm
GT_:                0400 DEFINED AT LINE 392 IN MAIN.asm
LT_:                0400 DEFINED AT LINE 393 IN MAIN.asm
GRAVE_:             0400 DEFINED AT LINE 394 IN MAIN.asm
RPAREN_:            0400 DEFINED AT LINE 395 IN MAIN.asm
LBRACK_:            0400 DEFINED AT LINE 396 IN MAIN.asm
RBRACK_:            0400 DEFINED AT LINE 397 IN MAIN.asm
LPAREN_:            0400 DEFINED AT LINE 398 IN MAIN.asm
QUESTION_:          0400 DEFINED AT LINE 399 IN MAIN.asm
HASH_:              0400 DEFINED AT LINE 400 IN MAIN.asm
STAR_:              0400 DEFINED AT LINE 401 IN MAIN.asm
NUM_:               0402 DEFINED AT LINE 404 IN MAIN.asm
VAR_:               0405 DEFINED AT LINE 407 IN MAIN.asm
VAR1:               040C DEFINED AT LINE 411 IN MAIN.asm
VAR2:               041A DEFINED AT LINE 420 IN MAIN.asm
                    > USED AT LINE 417 IN MAIN.asm
BANG_:              041D DEFINED AT LINE 424 IN MAIN.asm
ASSIGN:             041D DEFINED AT LINE 425 IN MAIN.asm
ASSIGN1:            042B DEFINED AT LINE 435 IN MAIN.asm
                    > USED AT LINE 432 IN MAIN.asm
PLUS_:              042D DEFINED AT LINE 438 IN MAIN.asm
CALL_:              043B DEFINED AT LINE 448 IN MAIN.asm
DOT_:               0445 DEFINED AT LINE 456 IN MAIN.asm
DOT2:               0449 DEFINED AT LINE 459 IN MAIN.asm
SEMI_:              0450 DEFINED AT LINE 464 IN MAIN.asm
COLON_:             0461 DEFINED AT LINE 472 IN MAIN.asm
SLASH_:             0464 DEFINED AT LINE 475 IN MAIN.asm
ALT_:               0464 DEFINED AT LINE 476 IN MAIN.asm
PAGE6:              0500 DEFINED AT LINE 485 IN MAIN.asm
ANOP_:              0500 DEFINED AT LINE 487 IN MAIN.asm
FALSEX_:            0502 DEFINED AT LINE 490 IN MAIN.asm
PRINTCHAR_:         0505 DEFINED AT LINE 493 IN MAIN.asm
PROMPT_:            050C DEFINED AT LINE 499 IN MAIN.asm
GO_:                0511 DEFINED AT LINE 503 IN MAIN.asm
GO1:                0512 DEFINED AT LINE 505 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
GO2:                052B DEFINED AT LINE 518 IN MAIN.asm
                    > USED AT LINE 513 IN MAIN.asm
GO3:                052E DEFINED AT LINE 521 IN MAIN.asm
                    > USED AT LINE 508 IN MAIN.asm
NEWLN_:             0530 DEFINED AT LINE 524 IN MAIN.asm
TRUEX_:             0535 DEFINED AT LINE 528 IN MAIN.asm
VARACCESS_:         0538 DEFINED AT LINE 531 IN MAIN.asm
PRINTDEC:           0541 DEFINED AT LINE 544 IN MAIN.asm
                    > USED AT LINE 458 IN MAIN.asm
                    > USED AT LINE 14
                    > USED AT LINE 19
PRINTDEC2:          0550 DEFINED AT LINE 555 IN MAIN.asm
                    > USED AT LINE 546 IN MAIN.asm
PRINTDEC4:          0572 DEFINED AT LINE 571 IN MAIN.asm
                    > USED AT LINE 559 IN MAIN.asm
                    > USED AT LINE 561 IN MAIN.asm
                    > USED AT LINE 563 IN MAIN.asm
                    > USED AT LINE 565 IN MAIN.asm
                    > USED AT LINE 568 IN MAIN.asm
PRINTDEC5:          0574 DEFINED AT LINE 573 IN MAIN.asm
                    > USED AT LINE 576 IN MAIN.asm
PRINTDEC6:          0584 DEFINED AT LINE 585 IN MAIN.asm
                    > USED AT LINE 580 IN MAIN.asm
PRINTDEC7:          0585 DEFINED AT LINE 587 IN MAIN.asm
                    > USED AT LINE 584 IN MAIN.asm
DEF:                0589 DEFINED AT LINE 595 IN MAIN.asm
                    > USED AT LINE 473 IN MAIN.asm
DEF0:               0597 DEFINED AT LINE 604 IN MAIN.asm
                    > USED AT LINE 599 IN MAIN.asm
DEF1:               05A2 DEFINED AT LINE 611 IN MAIN.asm
                    > USED AT LINE 603 IN MAIN.asm
                    > USED AT LINE 618 IN MAIN.asm
DEF2:               05AC DEFINED AT LINE 619 IN MAIN.asm
                    > USED AT LINE 617 IN MAIN.asm
DEF3:               05AD DEFINED AT LINE 621 IN MAIN.asm
NUM:                05B3 DEFINED AT LINE 625 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
NUM0:               05BC DEFINED AT LINE 631 IN MAIN.asm
                    > USED AT LINE 629 IN MAIN.asm
NUM1:               05BD DEFINED AT LINE 633 IN MAIN.asm
                    > USED AT LINE 650 IN MAIN.asm
NUM2:               05D5 DEFINED AT LINE 651 IN MAIN.asm
                    > USED AT LINE 636 IN MAIN.asm
                    > USED AT LINE 638 IN MAIN.asm
NUM3:               05E0 DEFINED AT LINE 659 IN MAIN.asm
                    > USED AT LINE 654 IN MAIN.asm
DSIZE:              0080 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 8 IN ram.asm
VARS_SIZE:          0034 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 97 IN MAIN.asm
                    > USED AT LINE 40 IN ram.asm
                    > USED AT LINE 41 IN ram.asm
TIB:                0800 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 183 IN MAIN.asm
                    > USED AT LINE 192 IN MAIN.asm
                    > USED AT LINE 209 IN MAIN.asm
RSTACK:             0980 DEFINED AT LINE 11 IN ram.asm
                    > USED AT LINE 89 IN MAIN.asm
DSTACK:             0A00 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 131 IN MAIN.asm
                    > USED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 242 IN MAIN.asm
                    > USED AT LINE 27
STACK:              0A00 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 445 IN IOSerial.asm
TBPTR:              0A00 DEFINED AT LINE 16 IN ram.asm
VTEMP1:             0A02 DEFINED AT LINE 17 IN ram.asm
VTEMP2:             0A04 DEFINED AT LINE 18 IN ram.asm
RST08:              0A06 DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 447 IN IOSerial.asm
RST10:              0A08 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 113 IN IOSerial.asm
                    > USED AT LINE 448 IN IOSerial.asm
RST18:              0A0A DEFINED AT LINE 22 IN ram.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 449 IN IOSerial.asm
RST20:              0A0C DEFINED AT LINE 23 IN ram.asm
                    > USED AT LINE 125 IN IOSerial.asm
                    > USED AT LINE 450 IN IOSerial.asm
RST28:              0A0E DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 131 IN IOSerial.asm
                    > USED AT LINE 451 IN IOSerial.asm
RST30:              0A10 DEFINED AT LINE 25 IN ram.asm
                    > USED AT LINE 137 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
BAUD:               0A12 DEFINED AT LINE 26 IN ram.asm
INTVEC:             0A14 DEFINED AT LINE 27 IN ram.asm
                    > USED AT LINE 143 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
NMIVEC:             0A16 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
GETCVEC:            0A18 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 435 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
PUTCVEC:            0A1A DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
OPCODES:            0B00 DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 104 IN MAIN.asm
ALTCODES:           0B5E DEFINED AT LINE 35 IN ram.asm
VARS:               0C00 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 93 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
DEFS:               0C34 DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 247 IN MAIN.asm
ALTVARS:            0C68 DEFINED AT LINE 43 IN ram.asm
VBYTEMODE:          0C6A DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 415 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
VCARRY:             0C6C DEFINED AT LINE 46 IN ram.asm
                    > USED AT LINE 445 IN MAIN.asm
VHEAPPTR:           0C76 DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 101 IN MAIN.asm
                    > USED AT LINE 601 IN MAIN.asm
                    > USED AT LINE 606 IN MAIN.asm
                    > USED AT LINE 622 IN MAIN.asm
VTIBPTR:            0C7C DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 140 IN MAIN.asm
                    > USED AT LINE 208 IN MAIN.asm
VREMAIN:            0C8A DEFINED AT LINE 61 IN ram.asm
VSTKSTART:          0C8C DEFINED AT LINE 62 IN ram.asm
                    > USED AT LINE 87 IN MAIN.asm
VBASEPTR:           0C9C DEFINED AT LINE 71 IN ram.asm
                    > USED AT LINE 90 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
                    > USED AT LINE 232 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
                    > USED AT LINE 354 IN MAIN.asm
                    > USED AT LINE 465 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
                    > USED AT LINE 517 IN MAIN.asm
VPOINTER:           0C9E DEFINED AT LINE 72 IN ram.asm
                    > USED AT LINE 412 IN MAIN.asm
                    > USED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
HEAP:               0CA0 DEFINED AT LINE 74 IN ram.asm
                    > USED AT LINE 100 IN MAIN.asm
TESTSSTART:         4000 DEFINED AT LINE 17
                    > USED AT LINE 10
EXPECTM_0_1232S31:  404E DEFINED AT LINE 23
                    > USED AT LINE 10
